/*
 * Copyright 2024 ElectronLab
 * Copyright 2025-2026 Frank Stettner (frank-stettner@gmx.net)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include QMK_KEYBOARD_H
#include <stdio.h>
#include <string.h>
#include "keymap_german.h"
#include "klor.h"


/****************
 * Custorm Layers
 ****************/
enum klor_layers {
    _QWERTZ,
    _BUTECK,
    _SYM,
    _NUM,
    _NAV,
};


/*****************
 * Custom Keycodes
 *****************/
enum custom_keycodes {
    LAYOUT_SWAP = SAFE_RANGE,
    OS_SWAP,
    MAKE_H,
};


/********************
 * Custom Macro Names
 ********************/

/* Home Row Mod QWERTZ Layer */
#define GUI_A    MT(MOD_LGUI, KC_A)
#define ALT_S    MT(MOD_LALT, KC_S)
#define CTL_D    MT(MOD_LCTL, KC_D)
#define SHT_F    MT(MOD_LSFT, KC_F)
#define SHT_J    MT(MOD_RSFT, KC_J)
#define CTL_K    MT(MOD_RCTL, KC_K)
#define ALT_L    MT(MOD_LALT, KC_L)
#define GUI_OE   MT(MOD_RGUI, DE_ODIA)
/* Home Row Mod BuTeck Layer */
#define GUI_H    MT(MOD_LGUI, KC_H)
#define ALT_I    MT(MOD_LALT, KC_I)
#define CTL_E    MT(MOD_LCTL, KC_E)
#define SHT_A    MT(MOD_LSFT, KC_A)
#define SHT_T    MT(MOD_RSFT, KC_T)
#define CTL_R    MT(MOD_RCTL, KC_R)
#define ALT_N    MT(MOD_LALT, KC_N)
#define GUI_S    MT(MOD_RGUI, KC_S)
/* Home Row Mod Symbol Layer */
#define GUI_BSLS MT(MOD_LGUI, DE_BSLS)
#define ALT_SLSH MT(MOD_LALT, DE_SLSH)
#define CTL_LCBR MT(MOD_LCTL, DE_LCBR)
#define SHT_RCBR MT(MOD_LSFT, DE_RCBR)
#define SHT_LPRN MT(MOD_RSFT, DE_LPRN)
#define CTL_RPRN MT(MOD_RCTL, DE_RPRN)
#define ALT_MINS MT(MOD_LALT, DE_MINS)
#define GUI_DQUO MT(MOD_RGUI, DE_DQUO)
/* Home Row Mod Number Layer */
#define GUI_F11  MT(MOD_LGUI, KC_F11)
#define ALT_F4   MT(MOD_LALT, KC_F4)
#define CTL_F5   MT(MOD_LCTL, KC_F5)
#define SHT_F6   MT(MOD_LSFT, KC_F6)
#define SHT_4    MT(MOD_RSFT, KC_4)
#define CTL_5    MT(MOD_RCTL, KC_5)
#define ALT_6    MT(MOD_LALT, KC_6)


/***********
 * My Keymap
 ***********/
const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {

    [_QWERTZ] = LAYOUT_polydactyl(
                  KC_Q,     KC_W,     KC_E,     KC_R,     KC_T,                          DE_Z,     KC_U,     KC_I,     KC_O,     KC_P,
        DE_SS,    GUI_A,    ALT_S,    CTL_D,    SHT_F,    KC_G,                          KC_H,     SHT_J,    CTL_K,    ALT_L,    GUI_OE,   DE_ADIA,
        XXXXXXX,  DE_Y,     KC_X,     KC_C,     KC_V,     KC_B,     KC_MUTE,   KC_MPLY,  KC_N,     KC_M,     KC_COMM,  KC_DOT,   DE_MINS,  DE_UDIA,
                                    MO(_SYM), KC_SPC, MO(_NAV), LCTL_T(KC_ESC), KC_TAB,  MO(_NUM), KC_ENT,   MO(_SYM)
    ),

    [_BUTECK] = LAYOUT_polydactyl(
                  KC_B,     KC_U,     KC_DOT,   KC_COMM,  DE_UDIA,                       KC_P,     KC_C,     KC_L,     KC_M,     KC_F,
        DE_SS,    GUI_H,    ALT_I,    CTL_E,    SHT_A,    KC_O,                          KC_D,     SHT_T,    CTL_R,    ALT_N,    GUI_S,    KC_X,
        XXXXXXX,  KC_K,     DE_Y,     DE_ODIA,  DE_ADIA,  KC_Q,     KC_MUTE,   KC_MPLY,  KC_J,     KC_G,     KC_W,     KC_V,     DE_Z,     XXXXXXX,
                                    MO(_SYM), KC_SPC, MO(_NAV), LCTL_T(KC_ESC), KC_TAB,  MO(_NUM), KC_ENT,   MO(_SYM)
    ),

    [_SYM] = LAYOUT_polydactyl(
                  DE_AT,    DE_MINS,  DE_LBRC,  DE_RBRC,  DE_CIRC,                       DE_EXLM,  DE_LABK,  DE_RABK,  DE_EQL,   DE_AMPR,
        XXXXXXX,  GUI_BSLS, ALT_SLSH, CTL_LCBR, SHT_RCBR, DE_ASTR,                       DE_QUES,  SHT_LPRN, CTL_RPRN, ALT_MINS, GUI_DQUO, XXXXXXX,
        DE_DEG,   DE_HASH,  DE_DLR,   DE_PIPE,  DE_TILD,  DE_GRV,   KC_MUTE,   KC_MPLY,  DE_PLUS,  DE_PERC,  DE_SCLN,  DE_COLN,  DE_QUOT,  XXXXXXX,
                                      _______,  XXXXXXX,  _______,  XXXXXXX,   XXXXXXX,  _______,  XXXXXXX,  _______
    ),

    [_NUM] = LAYOUT_polydactyl(
                  KC_F12,   KC_F7,    KC_F8,    KC_F9,    XXXXXXX,                       XXXXXXX,  KC_7,     KC_8,     KC_9,     XXXXXXX,
        QK_BOOT,  GUI_F11,  ALT_F4,   CTL_F5,   SHT_F6,   XXXXXXX,                       XXXXXXX,  SHT_4,    CTL_5,    ALT_6,    KC_RGUI,  XXXXXXX,
        XXXXXXX,  KC_F10,   KC_F1,    KC_F2,    KC_F3,    XXXXXXX,  KC_MUTE,   KC_MPLY,  KC_0,     KC_1,     KC_2,     KC_3,     XXXXXXX,  XXXXXXX,
                                      _______,  XXXXXXX,  _______,  XXXXXXX,   XXXXXXX,  _______,  XXXXXXX,  _______
    ),

    [_NAV] = LAYOUT_polydactyl(
                  RM_NEXT,  RM_HUEU,  RM_SPDU,  XXXXXXX,  KC_VOLU,                       KC_HOME,  KC_PGDN,  KC_PGUP,  KC_END,   XXXXXXX,
        RM_VALU,  KC_LGUI,  KC_LALT,  KC_LCTL,  KC_LSFT,  KC_VOLD,                       KC_LEFT,  KC_DOWN,  KC_UP,    KC_RGHT,  XXXXXXX,  XXXXXXX,
        RM_VALD,  KC_PSCR,  RM_HUED,  RM_SPDD,  XXXXXXX,  KC_MUTE,  KC_MUTE,   KC_MPLY,  XXXXXXX,  KC_BSPC,  XXXXXXX,  KC_DEL,   XXXXXXX,  XXXXXXX,
                                      _______,  XXXXXXX,  _______,  XXXXXXX,   XXXXXXX,  _______,  XXXXXXX,  LAYOUT_SWAP
    ),
};


/******
 * Init
 ******/
void keyboard_post_init_user(void) {
    debug_enable=true;
    //debug_matrix=true;
    //debug_keyboard=true;
    //debug_mouse=true;
}


/*****************************
 * Customizing Keys and Macros
 *****************************/
bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
    /* This makes HRM for the symbol layer working
     * see https://docs.qmk.fm/mod_tap#changing-tap-function
     */
    case GUI_BSLS:
        if (record->tap.count && record->event.pressed) {
            tap_code16(DE_BSLS);
            return false;
        }
        break;
    case ALT_SLSH:
        if (record->tap.count && record->event.pressed) {
            tap_code16(DE_SLSH);
            return false;
        }
        break;
    case CTL_LCBR:
        if (record->tap.count && record->event.pressed) {
            tap_code16(DE_LCBR);
            return false;
        }
        break;
    case SHT_RCBR:
        if (record->tap.count && record->event.pressed) {
            tap_code16(DE_RCBR);
            return false;
        }
        break;
    case SHT_LPRN:
        if (record->tap.count && record->event.pressed) {
            tap_code16(DE_LPRN);
            return false;
        }
        break;
    case CTL_RPRN:
        if (record->tap.count && record->event.pressed) {
            tap_code16(DE_RPRN);
            return false;
        }
        break;
    case GUI_DQUO:
        if (record->tap.count && record->event.pressed) {
            tap_code16(DE_DQUO);
            return false;
        }
        break;
    /* Swap OSes */
    case OS_SWAP:
        if (record->event.pressed) {
            if (!keymap_config.swap_lctl_lgui) {
                /* MAC */
                keymap_config.swap_lctl_lgui = true;
                #ifdef AUDIO_ENABLE
                PLAY_SONG(mac_song);
                #endif
            }
            else {
                /* Linux */
                keymap_config.swap_lctl_lgui = false;
                #ifdef AUDIO_ENABLE
                PLAY_SONG(winxp_song);
                #endif
            }
            //eeconfig_update_keymap(keymap_config.raw); // Not working?
            /* Clear to prevent stuck keys */
            clear_keyboard();
            return false;
        }
        break;
    /* Layers */
    case LAYOUT_SWAP:
        if (record->event.pressed) {
            /* See https://github.com/qmk/qmk_firmware/issues/13196#issuecomment-2282686675 */
            uint8_t active_layer = get_highest_layer(default_layer_state);
            if (active_layer == _QWERTZ) {
                set_single_persistent_default_layer(_BUTECK);
                layer_state_set(_BUTECK | layer_state);
            } else {
                set_single_persistent_default_layer(_QWERTZ);
                layer_state_set(_QWERTZ | layer_state);
            }
            return false;
        }
        break;
    /* QMK Stuff */
    case MAKE_H:
        if (record->event.pressed) {
            SEND_STRING("qmk compile -kb klor -km default");
            tap_code(KC_ENTER);
        }
        break;
    }
    return true;
}

uint16_t get_tapping_term(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
    case SHT_F:
    case SHT_J:
    case SHT_A:
    case SHT_T:
        return TAPPING_TERM - 150;
    default:
        return TAPPING_TERM;
    }
}

/***************
 * Custom Sounds
 ***************/
#ifdef AUDIO_ENABLE
    #define WINXP_SOUND W__NOTE(_DS6), Q__NOTE(_DS5), H__NOTE(_AS5), H__NOTE(_GS5), H__NOTE(_DS5), H__NOTE(_DS6), H__NOTE(_AS5)
    #define MAC_SOUND S__NOTE(_CS5), B__NOTE(_C5)

    float winxp_song[][2] = SONG(WINXP_SOUND);
    float mac_song[][2] = SONG(MAC_SOUND);
#endif


/***************
 * OLED Graphics
 ***************/
#ifdef OLED_ENABLE

char layer_state_str[24] = "";

/* Various Status Stuff */
void render_os_lock_status(void) {
    static const char PROGMEM sep_v[] = {0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0};
    static const char PROGMEM sep_h1[] = {0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0};
    static const char PROGMEM sep_h2[] = {0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0xE1, 0};
    static const char PROGMEM face_1[] = {0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0xE1, 0};
    static const char PROGMEM face_2[] = {0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xE1, 0};
    static const char PROGMEM face_3[] = {0xE1, 0xE1, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xE1, 0};
    static const char PROGMEM os_mac_1[] = {0x95, 0x96, 0};
    static const char PROGMEM os_mac_2[] = {0xB5, 0xB6, 0};
    static const char PROGMEM os_win_1[] = {0x97, 0x98, 0};
    static const char PROGMEM os_win_2[] = {0xB7, 0xB8, 0};
    static const char PROGMEM os_linux_1[] = {0x99, 0x9A, 0};
    static const char PROGMEM os_linux_2[] = {0xB9, 0xBA, 0};
    static const char PROGMEM os_android_1[] = {0x9B, 0x9C, 0};
    static const char PROGMEM os_android_2[] = {0xBB, 0xBC, 0};
    static const char PROGMEM scroll_lock[] = {0x8F, 0x90, 0};
    static const char PROGMEM num_lock[] = {0x91, 0x92, 0};
    static const char PROGMEM caps_lock[] = {0x93, 0x94, 0};
    static const char PROGMEM blank_lock[] = {0xE1, 0xE1, 0};
    #ifdef AUDIO_ENABLE
        static const char PROGMEM aud_en[] = {0xAF, 0xB0, 0};
        static const char PROGMEM aud_di[] = {0xCF, 0xD0, 0};
    #endif
    #ifdef HAPTIC_ENABLE
        static const char PROGMEM hap_en[] = {0xB1, 0xB2, 0};
        static const char PROGMEM hap_di[] = {0xCF, 0xD0, 0};
    #endif

    /* OS Mode Status */

    oled_write_ln_P(sep_v, false);

    //os_variant_t detected_os = detected_host_os();
    //switch (detected_os) {
    //case OS_LINUX:
    //    oled_write_P(os_linux_1, false);
    //    break;
    //case OS_WINDOWS:
    //    oled_write_P(os_windows_1, false);
    //    break;
    //case OS_MACOS:
    //case OS_IOS
    //    oled_write_P(os_mac_1, false);
    //    break;
    //}
    if (keymap_config.swap_lctl_lgui) {
        oled_write_P(os_mac_1, false);
    } else {
        oled_write_P(os_linux_1, false);
    }

    oled_write_P(sep_h1, false);
    oled_write_P(face_1, false);

    if (keymap_config.swap_lctl_lgui) {
        oled_write_P(os_mac_2, false);
    } else {
        oled_write_P(os_linux_2, false);
    }

    oled_write_P(sep_h1, false);
    oled_write_P(face_2, false);
    oled_write_P(sep_h1, false);
    oled_write_P(face_3, false);

    /* Lock Key Layer Status */

    led_t led_usb_state = host_keyboard_led_state();

    /* Numlock */
    if (led_usb_state.num_lock) {
        oled_write_P(num_lock, false);
    } else {
        oled_write_P(blank_lock, false);
    }
    /* Capslock */
    if (led_usb_state.caps_lock) {
        oled_write_P(caps_lock, false);
    } else {
        oled_write_P(blank_lock, false);
    }
    /* Scrolllock */
    if (led_usb_state.scroll_lock) {
        oled_write_P(scroll_lock, false);
    } else {
        oled_write_P(blank_lock, false);
    }

    /* Hardware Feature Status */

    oled_write_P(sep_h2, false);

    #ifndef AUDIO_ENABLE
        oled_write_P(blank_lock, false);
    #endif
    #ifdef AUDIO_ENABLE
        if (is_audio_on()) {
            oled_write_P(aud_en, false);
        } else {
            oled_write_P(aud_di, false);
        }
    #endif

    #ifndef HAPTIC_ENABLE
        oled_write_P(blank_lock, false);
    #endif
    #ifdef HAPTIC_ENABLE
        if (haptic_get_enable()) {
            oled_write_P(hap_en, false);
        } else {
            oled_write_P(hap_di, false);
        }
    #endif
}

/* Layer status */
layer_state_t layer_state_set_user(layer_state_t state) {
    switch (get_highest_layer(state | default_layer_state)) {
    case _QWERTZ:
        strcpy(layer_state_str, "BASE QWERTZ");
        break;
    case _BUTECK:
        strcpy(layer_state_str, "BASE BuTeck");
        break;
    case _SYM:
        strcpy(layer_state_str, "SYMBOLS");
        break;
    case _NUM:
        strcpy(layer_state_str, "NUMBERS");
        break;
    case _NAV:
        strcpy(layer_state_str, "NAVIGATION");
        break;
    default:
        strcpy(layer_state_str, "XXXXXX");
    }
    return state;
}

/* Write to OLED */
bool oled_task_user(void) {
    if (is_keyboard_master()) {
        /* Primary Side */
        oled_write_ln(layer_state_str, false);
        render_os_lock_status();
    } else {
        /* Secondary Side */
        static const char PROGMEM klor_face[] = {
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xf0, 0xf0, 0xf0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xf0, 0xf0, 0xf0,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
            0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 0xf0,
            0xf0, 0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 0xf0, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xf0, 0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        };
        oled_write_raw_P(klor_face, sizeof(klor_face));
    }
    return false;
}
#endif


/**********
 * Encoders
 **********/
#ifdef ENCODER_MAP_ENABLE
const uint16_t PROGMEM encoder_map[][NUM_ENCODERS][NUM_DIRECTIONS] = {
    [_QWERTZ] = { ENCODER_CCW_CW(KC_VOLD, KC_VOLU), ENCODER_CCW_CW(MS_WHLD, MS_WHLU) },
    [_BUTECK] = { ENCODER_CCW_CW(KC_VOLD, KC_VOLU), ENCODER_CCW_CW(MS_WHLD, MS_WHLU) },
    [_SYM] =    { ENCODER_CCW_CW(KC_VOLD, KC_VOLU), ENCODER_CCW_CW(KC_MPRV, KC_MNXT) },
    [_NUM] =    { ENCODER_CCW_CW(KC_VOLD, KC_VOLU), ENCODER_CCW_CW(KC_MPRV, KC_MNXT) },
    [_NAV] =    { ENCODER_CCW_CW(KC_VOLD, KC_VOLU), ENCODER_CCW_CW(KC_MPRV, KC_MNXT) },
};
#endif

/*

    ▐█    ▟▛ ▐█     ▄▆▀▀▀▀▀▀▆▄  ▐█▀▀▀▀▀█▌
    ▐█   ▟▛  ▐█    ▟▛        ▜▙ ▐█     █▌
    ▐█  ▟▛   ▐█   ▐█          █▋▐█     █▌
    ▐█ ▟█▙   ▐█   ▐█          █▋▐█▀▀▜█▀▀▘
    ▐█▟▛ ▜▙  ▐█    ▜▙        ▟▛ ▐█   ▜▙
    ▐█▛   ▜▙ ▐█▄▄▄▄ ▀▜▆▄▄▄▄▆▛▀  ▐█    ▜▙

              ▄██████████████▄
              ████████████████
         ▄██████▀  ▀████▀  ▀██████▄
         ███████▄  ▄████▄  ▄███████
         ███████████▀▀▀▀███████████
         ▀█████████▀ ▄▄ ▀█████████▀
              ████▀ ▄██▄ ▀████
              ████▄▄████▄▄████

*/

